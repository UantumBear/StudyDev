# RabbitMQ 개념

## RabbitMQ 란?
오픈 소스 메시지 브로커 소프트웨어.
서로 다른 시스템 간에 메시지를 전송하고 받는 것을 도와주는 도구이다.
 단순한 관리자 도구가 아닌, 비동기 통신의 메시지 브로커 소프트웨어 tool 이다.
## RabbitMQ의 특징
### 1. 분산
메시지를 queue 에 저장한다.
메시지를 보내는 쪽과(producer) 받는 쪽(consumer)간의 속도 차이를 관리 할 수 있고, 
부하를 분산 시킬 수 있다. 
### 2. 비동기 통신 
시스템 간 비동기 통신을 지원한다. 메시지를 보내는 쪽과 받는 쪽이 동시에 온라인 일 필요가 없다는 의미이다.
예를 들어, 한 시스템이 메시지를 RabbitMQ에 전송하면, 다른 시스템이 준비될 때까지 queue에 보관된다.
### 3. 다양한 메시징 패턴 지원
#### 3-1) Publish / Subscribe (Pub/Sub)
메시지를 보내는 쪽(producer)은 특정 큐에 직접 메시지를 보내지 않는다.
교환소(exchange)에 메시지를 보내면, 하나 이상의 queue 가 이 교환소에 바인딩 되어 메시지를 수신한다.
=> 보통 여러 수신자에게 동시에 메시지를 전달할 때 사용된다. 주식 시세 업데이트, 이벤트 알림 등
#### 3-2) Routing
  라우팅 패턴에서는 교환에 메시지를 보낼 때 특정 '라우팅 키'를 지정한다.
  키에 따라 메시지는 바인딩 된 큐의 일부에만 전달된다.
  특정 유형의 메시지를 특정 수신자에게만 전달 할 때 사용.
  예를 들어, 오류 메시지 : 오류 로그 처리 큐, 정보 메시지: 정보 처리 큐
#### 3-3) Topics
라우팅 패턴의 확장.
라우팅 키에 따라 메시지를 분류하되, 더 복잡하고 유연한 라우팅 규칙을 제공한다.
라우팅 키는 ‘.’(점) 으로 구분된 여러 단어를 포함하며, queue 바인딩 시 와일드 카드를 사용할 수 있다.
=> stock.us.nasdaq, stock.eu.london 과 같은 키로 주식 시장 메시지 분류.
<div>
    와일드 카드란?
    특정 패턴을 일치시키기 위해 사용되는 문자. 
    
    ‘*’ : 한 개의 단어를 대체한다.
    예) news.abc.sports, news.bbc.sports <-> news.*.sports
    
    ‘#’:  n 개의 단어를 대체한다. (0개 포함)
    예) news.abc.sports, news.bbc.music <-> news.#
</div>

#### 3-4) Remote Procedure Calls (RPC) 
클라이언트가 서버에 요청 전송, 서버가 응답을 돌려주는 방식으로 작동한다.
클라이언트가 메시지와 함께 응답을 받을 큐에 대한 정보를 전송하면, 서버는 그 큐로 응답 메시지를 보낸다. 
=> 동기식 요청-응답에 사용한다. 예를 들어, 클라이언트로 데이터 처리를 요청 한 후, 처리 결과를 기다리는 경우 등
4. [신뢰성]
   메시지의 신뢰성을 보장하여, 서버 장애가 발생해도 메시지가 유실되지 않도록 지원한다.
   => 근데 우리는 왜 채팅 상담 메시지가 누락되었을까? RabbitMQ의 로그를 쌓아야 에러 시점을 확인 할 수 있지 않나..?

##### 데이터 전달 과정
틀릴 수 있음..
1. 사용자가 챗봇 화면에 메시지를 입력
2. 챗봇 서비스가 메시지를 상담사 서버로 전달
 2-1. 챗봇 서비스(RabbitMQ client, producer)가 메시지를 특정 Exchange로 전달.
 2-2. Exchange 가 라우팅 규칙에 따라 메시지를 적절한 Queue로 전달
 2-3. Queue가 메시지를 상담사 서버(consumer)로 전달 
3. 상담사는 상담 화면에 응답을 입력 
 3-1. 상담사 서버는 응답 메시지를 RabbitMQ 서버로 전달. 
 3-2. RabbitMQ는 메시지를 특정 Exchange로 전달.
 3-3. Exchange는 응답 메시지를 사용자를 위한 Queue로 라우팅하여 전달. 
4. 챗봇 서비스가 응답 메시지를 사용자의 챗봇 화면으로 전달
4-1. 챗봇 서비스(이때는 consumer)는 Queue 에서 응답 메시지를 가져와서
해당 json을 챗봇 시스템의.. API Contoller 로 전달.
프론트 단에서 만들어둔 레이아웃 형태로 처리하여 사용자의 챗봇 화면으로 표시.

# RabbitMQ 관련 용어 설명

### [ Details ]
**SSL/TLS**: 해당 연결이 SSL/TLS 를 사용해서 암호화 되는지 여부  
**Protocol**: 클라이언트가 사용하는 프로토콜 버전 (AMQP 0-9-1 or STOMP 1.x 등)  
**Channels**: 현재 연결을 통해 열린 채널의 수  
**Channel max**: 이 연결에서 허용하는 최대 채널 수  
**Frame max**: 한 프레임 내에서 전송할 수 있는 최대 바이트 크기  
**Auth mechanism**: 인증 메커니즘 (PLAIN, EXTERNAL 등)  
**Client**: 클라이언트 어플리케이션 정보  

### [ Network ]
**From client**: 클라이언트에서 서버로 전송된 데이터 속도  
**To client**: 서버에서 클라이언트로 전송된 데이터 속도  
**Heartbeat**: 서버와 클라이언트 사이의 연결을 유지하기 위해 정기적으로 전송되는 신호의 간격  
**Connected at**: 클라이언트가 서버에 연결된 시점의 타임스탬프  

---
## Channels: 채널
클라이언트가 RabbitMQ와 통신하기 위해 사용하는 경로

채널과 연결은 어떻게 다른 거지..?  
-> 하나의 Connections (IP:port) 안에 여러 개의 채널 이 있음! IP:port (number)


### [Overview]
**Channel**: 채널 고유 식별자. 보통 IP:port (number) 를 사용한다.  
**Node**: 채널이 연결된 RabbitMQ 노드  
**User name**: 채널을 생성한 사용자의 이름  
**Mode**: 채널 작동 모드 (confirm 등)  
**State**: 채널 현재 상태 (running, idle)  

### [Detail]
**Unconfirmed**: confirm  모드에서 아직 RabbitMQ에 의해 확인되지 않은 메시지 수  
**Prefetch**: 한 번에 큐에서 가져오는(혹은 소비하는) 메시지의 최대 수  
**Unacked**: 소비자에 의해 수신되었지만 아직 acknowledgement를 받지 않은 메시지의 수  

### [Transactions]
**Uncommitted msgs**: 트랜잭션 모드에서 커밋 되지 않은 메시지의 수  
**Uncommitted acks**: 트랜잭션 모드에서 커밋 되지 않은 확인 응답의 수  

### [Message rates]
**Publish**: 채널을 통해 발행된 메시지의 비율(초당 메시지 수)  
**Confirm**: 메시지가 RabbitQM에 의해 받아들여진 비율  
**Return (mandatory)**: mandatory 플래그가 설정된 메시지가 라우팅 될 수 없을 때 반환된 메시지 비율  
**Deliver / get**: 소비자에게 전달되거나 get 요청을 통해 검색된 메시지 비율  
**Redelivered**: 이미 전달되었으나 ack를 받지 못하고 다시 전달된 메시지 비율  
**Ack**: 소비자가 처리를 완료하고 확인 응답을 보낸 메시지 비율  

---
## Exchanges 
#### 교환소 (메시지를 적합한 큐로 라우팅하는 곳)
**Name**: Exchanges의 고유 이름  
**Type**: 교환기의 타입.  
- **Direct** 로 설정: 메시지의 라우팅 키가 queue의 바인딩 키와 정확히 일치해야 메시지가 큐로 라우팅 된다.   
- **Fanout**로 설정: 라우팅 키와 상관없이, 모든 바인딩 된 큐로 메시지를 브로드캐스트 한다.  
- **Topic**으로 설정: 라우팅 키가 패턴 매칭(와일드카드)을 통해 큐에 바인딩 된다.   
- **Headers**로 설정: 라우팅 키 대신 메시지 헤더 세트를 기반으로 메시지를 라우팅한다.  
#### Features: 교환기의 속성
- **D: Durable.** 내구성 있는 교환기는 서버 재시작 후에도 교환기가 유지된다.
- **A: Auto-delete.** 마지막 큐가 바인딩을 해제하면 Exchange 가 자동으로 삭제된다
- **I: Internal.** 내부 교환기는 클라이언트로 부터 직접 메시지를 받지 않고, 다른 교환기를 통해서 메시지를 받는다.
**Policy**: 교환기에 적용된 정책 이름. TTL, 최대길이, 데드 레터 교환 등 교환기 동작 제어와 관련이 있다.
**Message rate in**: 교환기에서 들어오는 메시지 비율(초당 메시지 수)
**Message rate out**: 교환기에서 나가는 메시지 비율(초당 메시지 수)

---
## Queues
메시지를 임시로 저장하는 버퍼 역할, 소비자가 처리할 준비가 될 때까지 메시지를 보관한다.  

### [ Overview ]
**Name**: 큐의 고유한 이름    
**Features**: 큐의 속성, D(durable) A(auto-delete) E(exclusive) 등이 있다.    
**Policy**: 큐에 사용된 정책. TTL, 메시지 최대 길이, 우선 순위 등과 관련이 있다.    
**Consumers**: 해당 큐에 연결된 소비자의 수    
**Consumer utilization**: ??  
**State**: 큐의 상태 (running 실행 중, paused 일시 정지)  

### [ Messages ]
**Ready**: 소비자에 의해 처리될 준비가 된 메시지의 수  
**Unacked**: 소비자가 받아 처리 중이지만 아직 ack(확인 응답)을 보내지 않은 메시지의 수  
**In Memory**: 메모리에 저장된 메시지의 수  
**Total**: 큐에 있는 총 메시지의 수  

### [ Message bytes ]
**Ready**: 처리를 기다리는 메시지의 총 바이트 수   
**Unacked**: ack를 기다리는 메시지의 총 바이트 수  
**In Memory**: 메모리에 있는 메시지의 총 바이트 수  
**Persistent**: 디스크에 영구 저장된 메시지의 총 바이트 수  
**Total**: 큐에 있는 메시지의 총 바이트 수  

### [ Message rates ]
**incoming**: 큐로 들어오는 메시지의 비율(초당 메시지 수)  
**deliver / get**: 소비자가 큐에서 메시지를 가져가는 비율  
**redelivered**: 소비자에게 다시 전달된 메시지의 비율  
**ack**: 소비자가 처리를 완료하고 ack를 보낸 메시지의 비율  






