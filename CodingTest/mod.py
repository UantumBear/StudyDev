import sys

# 입력 받기
K, P, N = map(int, input().split()) # K:바이러스 수, P:증가율, N:총 시간(초)

# 바이러스는 1초당 P배씩 증가한다.
# 처음에 바이러스가 K마리 있었다면 N초 후에는 몇마리 인가? 단, 죽는 바이러스는 없다.

# 숫자가 너무 커지기 때문에 아래와 같이 계산하면 안됨.
# num = K * (P**N)
# r = num % 100000007

# 파이썬 거듭제곱 내장함수 pow() 사용하기
# pow(base, exp, mod)  :: base:거듭제곱의밑, exp:거듭제곱의지수, mod:(선택사항)결과를 특정 값으로 나눈 후의 나머지 값

MOD = 1000000007
r = K * pow(P, N, MOD) % MOD
print(r)

"""
- MOD 란..?
MOD 란 모듈러 연산에 사용되는 값으로, 결과를 제한하기 위해 특정 숫자로 나눴을 때의 나머지를 구하는 데 사용된다.
예를 들어, MOD = 1000000007 이라면, 모든 계산의 결과를 1000000007로 나눈 나머지만 사용한다.

- 모듈러 연산이란..?
Modular Arithmetic :: 나눗셈의 나머지를 계산하는 연산
우리가 알고 있는 a % b 가 모듈러 연산이다. (@return 나머지)

- 모듈러 연산은 왜 사용할까..?
애초에 왜 나머지를 구하는 계산을 하는걸까??
이유는 큰 숫자를 처리하기 위해서이다. 
컴퓨터는 큰 숫자를 직접 처리하기 어렵다. 너무 값이 크면 계산이 불가하다.
때문에 모듈러 연산을 사용하여, 값으 범위를 제한하면서 수학적 결과는 유지시키는 것이다.

- 1000000007..?
MOD = 1000000007 은 무엇일까?
이는 매우 큰 소수이다. (Prime Number)
10억보다는 크지만 32비트 정수 범위를 초과하지 않기 때문에 컴퓨터가 계산을 하는데에 최적화되어
주로 사용하는 MOD 값이다. 사실상 표준으로 자리잡은 것이다.

- 모듈러 연산의 수학적 성질..?
모듈러 연산은 반복해서 사용해도 수학적으로 문제가 없다.  당연하다..!수학적으로..  나머지니까..
ex)
덧셈::
(a+b)%MOD == (a+b)%MOD%MOD%MOD%MOD

그러니까, 문제에서 제약 조건을 보고,
해당 값이 너무 크다.! 하면 값이 넘어 갈 경우 MOD 로 나눠야 할 지 생각해야한다. 


"""