"""
1. DFS : Depth First Search   깊이 우선 탐색
    한 경로를 끝까지 탐색한 후 다시 돌아오는 방식. 재귀 호출을 사용하여 구현할 수 있다.
2. BFS : Breadth First Search 너비 우선 탐색
    Queue를 사용하여 한 단계씩 탐색을 확장하는 방식.
    일반적으로 최단 경로 문제에서 유용하다.

DFS, BFS 에서는 상하좌우 이동을 위한 방향 벡터를 생성한다.
현재 위치 (x,y) 에서 상하좌우의 위치를 탐색하기 위함이다.

예를 들어,
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1] 이면
방향 벡터를 활용하면 쉽게 이동할 수 있다.
for i in range(4): # 4가지 방향 탐색
    nx = x + dx[i]
    xy = y + dy[i]
"""

# Step 1. 문제 이해하기
# 첫번째 줄에는 지도의 크기 N 이 주어짐 ( N x N )
# 두번째 줄부터 N+1 번째 줄까지는 각 칸에 들어갈 숫자들이 주어짐 0:도로 / 1:장애물
# 그리고 연결된 뭉텅이 장애물 블록 별로 번호를 붙인다.
# 그리고 블록 내 장애물의 수를 오름차 순으로 정렬하여 출력한다.

# Step . 문제 해결하기
# 입력 받기
N = int(input().strip())
grid = [list(map(int, input().strip())) for _ in range(N)]
print("grid: ", grid)

# 1 DSF 깊이 우선 탐색 방식
import sys
# 방문 체크 리스트
visited = [[False] * N for _ in range(N)] # [False] * N 은 무슨 의미?
# 상하좌우 이동 방향 (dx, dy)
dx = [-1, 1, 0, 0]
dy = [0,0,-1,1]
"""
==> 이게 우리 평범한 사분면 생각하면 안되고 x 행, y 열이라고 생각해야 한다고 함..
1  2  3  4  5 
6  7  8  9  10
11 12 13 14 15
16 17 18 19 20  이런 숫자들이 4 X 5 개 있을 때,

1에서 2로 가는게 그 x축에서 이동하듯이 x+1 이 아니고.
1 == (0,0) , 2 == (0,1) ...  이런식으로 (행,열) 로 표기하고,
그래서,
위로 이동 == x-1
아래로 이동 == x+1  => [-1,1,0,0]
좌로 이동 == y-1
우로 이동 == y+1   => [0,0,-1,1]

정리하면
2차원 리스트 (배열) 의 좌표 시스템을 이해해야 함..

grid = [[1,2,3],
        [4,5,6],
        [7,8,9]]
각 좌표는
(0,0) (0,1) (0,2)
(1,0) (1,1) (1,2)
(2,0) (2,2) (2,3)
이렇게 표현 할 수 있고
이걸 실제 프로그램에서 쓰는 grid[0][0] 이거 말하는거

만약 현재 위치가 (0,0) 이라면
값은 d[0][0] 이고
상 : dx==-1 dy==0    하 x y 가 헷갈리는것 같다. row col 이 낫지 않나...

그래픽 좌표계에서는 x가 좌우 y 가 상하지만
파이썬 2차원 리스트 배열 표현에서는 x 가 row y 가 col 이고 이게 일반적이라고 한다..

"""

def dfs(x,y): # x,y 는 좌표
    stack = [(x,y)] # stack 은 무슨 역할? 좌표 데이터를 넣는 공간! 값은 안넣음!
    # 어디를 탐색했는지 방문한 좌표를 저장하고 다음 좌표를 정하기 위한 장소..
    visited[x][y] = True
    count = 1 # 현재 블록 개수

    while stack:
        cx, cy = stack.pop() # current x, current y 현재 좌표!
        for i in range(4): # 상하좌우 4방향 탐색
            nx, ny = cx + dx[i], cy + dy[i] # next x, next y !
            # 범위 내에 있고, 방문하지 않은 블록(1) 이라 하면,
            if 0 <= nx < N and 0 <= ny < N and not visited[nx][ny] and grid[nx][ny] == 1:
                visited[nx][ny] = True
                stack.append((nx, ny))
                count += 1 # 블록 개수 증가
    return count

